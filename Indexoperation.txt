package com;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;

public class IndexOperations {

	BufferedReader br=null;
	BufferedWriter bw =null;
	
	public void fileWrite(String fileName){
		try {
			bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), "utf-8"));
		} catch (UnsupportedEncodingException | FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	
	public void getTopK(int k) throws IOException {
		// TODO Auto-generated method stub
		LinkedList<Dictionary> dict = Index.getDictionary();
		bw.write("FUNCTION: getTopK "+k);
		bw.newLine();
		StringBuilder sb= new StringBuilder();
		sb.append("Result: ");
		for(int i=0;i<k;i++){
			sb.append(dict.get(i).getTerm()+", ");
		}
		String result=sb.toString();
		result=result.replaceAll(", +$", "");
		bw.write(result);
		bw.newLine();

	}


	public void readQueryFile(String queryFileName) {
		// TODO Auto-generated method stub
		try {
			br= new BufferedReader(new FileReader(queryFileName));
			String line;
			int flag=1;
			while((line=br.readLine())!=null){
				flag=0;
				String[] query = line.split(" ");
				for(int i=0;i<query.length;i++){
					getPostings(query[i]);
				}
				termAtATimeQueryAnd(query);
				termAtATimeQueryOr(query);
				docAtATimeQueryAnd(query);
				docAtATimeQueryOR(query);
			}
			if(flag==1){
				bw.write("Unable to read the file containing queries or the file is empty");
				bw.newLine();
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		finally{
			try {
				br.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

	}


	private void getPostings(String qString) throws IOException {
		// TODO Auto-generated method stub
		PostingsData postingsData =Index.getIndex().get(qString);

		if(postingsData!=null){

			LinkedList<Posting> listSortedDoc = postingsData.getPostingsListDAAT();
			LinkedList<Posting> listSortedFreq = postingsData.getPostingsListTAAT();

			bw.write("FUNCTION: getPostings "+qString);
			bw.newLine();

			StringBuffer sb1= new StringBuffer();
			sb1.append("Ordered by doc IDs:");

			StringBuffer sb2= new StringBuffer();
			sb2.append("Ordered by TF:");

			for(int i=0;i<listSortedDoc.size();i++){
				sb1.append(listSortedDoc.get(i).getDocID()+", ");
				sb2.append(listSortedFreq.get(i).getDocID()+", ");
			}
			String result1=sb1.toString();
			result1=result1.replaceAll(", +$", "");
			String result2=sb2.toString();
			result2=result2.replaceAll(", +$", "");
			bw.write(result1);
			bw.newLine();
			bw.write(result2);
			bw.newLine();

		}
		else{
			bw.write("FUNCTION: getPostings "+qString);
			bw.newLine();
			bw.write("term not found");
			bw.newLine();
		}
	}


	private void termAtATimeQueryAnd(String[] query) throws IOException {
		// TODO Auto-generated method stub

		StringBuffer querySb= new StringBuffer();
		querySb.append("FUNCTION: termAtATimeQueryAnd ");
		for(int z=0;z<query.length;z++){
			querySb.append(query[z]+", ");
		}
		String queryStr=querySb.toString();
		queryStr=queryStr.replaceAll(", +$", "");
		bw.write(queryStr);
		bw.newLine();

		PostingsData postingsDataZero =Index.getIndex().get(query[0]);
		if(postingsDataZero==null){
			bw.write("term not found");
			bw.newLine();
			return;
		}

		// Storing the postings list of the first query term as listSortedTAATZero 
		// This is done so that if there are no other query terms, then the postings list of the first query term is printed
		LinkedList<Posting> listSortedTAATZero=postingsDataZero.getPostingsListTAAT();
		int countComparisons=0;
		long startTime = System.nanoTime();

		for(int i=1;i<query.length;i++){
			PostingsData postingsDataI =Index.getIndex().get(query[i]);
			if(postingsDataI==null){
				bw.write("term not found");
				bw.newLine();
				return;
			}
			else{
				//Initializing a temporary List as empty. The AND of both the postings list is stored to the ANDList 
				LinkedList<Posting> ANDList= new LinkedList<Posting>();

				//Getting the postings list of the current query term
				LinkedList<Posting> listSortedTAAT=postingsDataI.getPostingsListTAAT();

				for(int j=0;j<listSortedTAATZero.size();j++){
					for(int k=0;k<listSortedTAAT.size();k++){
						countComparisons++;
						if(listSortedTAATZero.get(j).getDocID()==listSortedTAAT.get(k).getDocID()){
							ANDList.add(listSortedTAATZero.get(j));
							break;
						}

					}
				}
				listSortedTAATZero=ANDList;

			}

		}
		long endTime = System.nanoTime();
		double elapsedTime = ((endTime-startTime)/1000000000.0);
		if(listSortedTAATZero==null){
			bw.write("0 documents are found");
			bw.newLine();
			bw.write(countComparisons+" comparisons are made");
			bw.newLine();
			bw.write(elapsedTime+" seconds are used");
			bw.newLine();
			bw.write("nn comparisons are made with optimization");
			bw.newLine();
			bw.write("Result: ");
			bw.newLine();
		}
		else{
			bw.write(listSortedTAATZero.size()+" documents are found");
			bw.newLine();
			bw.write(countComparisons+" comparisons are made");
			bw.newLine();
			bw.write(elapsedTime+" seconds are used");
			bw.newLine();
			bw.write("nn comparisons are made with optimization");
			bw.newLine();
			StringBuffer sb = new StringBuffer();
			sb.append("Result: ");

			Collections.sort(listSortedTAATZero, new DocIDComparator());
			for(int i=0;i<listSortedTAATZero.size();i++){
				sb.append(listSortedTAATZero.get(i).getDocID()+", ");
			}
			String result=sb.toString();
			result=result.replaceAll(", +$", "");
			bw.write(result);
			bw.newLine();
		}
	}

	private void termAtATimeQueryOr(String[] query) throws IOException {
		// TODO Auto-generated method stub
		StringBuffer querySb= new StringBuffer();
		querySb.append("FUNCTION: termAtATimeQueryOr ");
		for(int z=0;z<query.length;z++){
			querySb.append(query[z]+", ");
		}
		String queryStr=querySb.toString();
		queryStr=queryStr.replaceAll(", +$", "");
		bw.write(queryStr);
		bw.newLine();

		PostingsData postingsDataZero =Index.getIndex().get(query[0]);
		int size=0;

		// This loop considers the situation of having the first k query terms not being present in the index
		// In such a case the first query term that is present in the list is stored in postingsDataZero
		while(postingsDataZero==null && size<query.length){
			size++;
			postingsDataZero =Index.getIndex().get(query[size]);
		}

		// If no term of the query terms is present in the index then the result of the termAtATimeQueryOr is empty 

		if(postingsDataZero==null){
			bw.write("term not found");
			bw.newLine();
			return;
		}

		int countComparisons=0;
		long startTime = System.nanoTime();

		//Initializing a temporary List as empty. The OR of all the postings lists are stored to the ORList 
		LinkedList<Posting> ORList = new LinkedList<Posting>();

		for(int i=0;i<query.length;i++){
			PostingsData postingsDataI =Index.getIndex().get(query[i]);

			//Getting the postings list of the current query term
			LinkedList<Posting> listSortedTAAT=postingsDataI.getPostingsListTAAT();

			if(i==0){
				for(int j=0;j<listSortedTAAT.size();j++){
					countComparisons++;
					ORList.add(listSortedTAAT.get(j));
				}
			}
			else{
				for(int j=0;j<listSortedTAAT.size();j++){
					int flag=0;
					for(int k=0;k<ORList.size();k++){
						countComparisons++;
						if(listSortedTAAT.get(j).getDocID()==ORList.get(k).getDocID()){
							flag=1;
							break;
						}
					}
					if(flag==0)
						ORList.add(listSortedTAAT.get(j));
				}
			}

		}
		long endTime = System.nanoTime();
		double elapsedTime = ((endTime-startTime)/1000000000.0);
		bw.write(ORList.size()+" documents are found");
		bw.newLine();
		bw.write(countComparisons+" comparisons are made");
		bw.newLine();
		bw.write(elapsedTime+" seconds are used");
		bw.newLine();
		bw.write("nn comparisons are made with optimization");
		bw.newLine();
		StringBuffer sb = new StringBuffer();
		sb.append("Result: ");

		Collections.sort(ORList, new DocIDComparator());
		Iterator<Posting> iterator= ORList.iterator();
		while(iterator.hasNext()){
			sb.append(iterator.next().getDocID()+", ");
		}
		String result=sb.toString();
		result=result.replaceAll(", +$", "");
		bw.write(result);
		bw.newLine();


	}

	private void docAtATimeQueryAnd(String[] query) throws IOException {
		// TODO Auto-generated method stub
		StringBuffer querySb= new StringBuffer();
		querySb.append("FUNCTION: docAtATimeQueryAnd ");
		for(int z=0;z<query.length;z++){
			querySb.append(query[z]+", ");
		}
		String queryStr=querySb.toString();
		queryStr=queryStr.replaceAll(", +$", "");
		bw.write(queryStr);
		bw.newLine();

		// Creating an ArrayList which stores the postings list of all the query terms
		LinkedList<LinkedList<Posting>> DAATList = new LinkedList<LinkedList<Posting>>();
		for(int i=0;i<query.length;i++){
			LinkedList<Posting> listSortedDAATTemp=Index.getIndex().get(query[i]).getPostingsListDAAT();
			if(listSortedDAATTemp==null){
				bw.write("term not found");
				bw.newLine();
				return;
			}
			else{
				DAATList.add(i, listSortedDAATTemp);
			}


		}

		int countComparisons=0;
		long startTime = System.nanoTime();

		LinkedList<Posting> ANDList= new LinkedList<Posting>();

		//postingsListAttay contains the pointers to each of the postingslist
		int pointerList[] = new int[DAATList.size()];

		// Initializing each element of the postingListArray to the first posting of each of the postings list
		for(int k=0;k<DAATList.size();k++){
			pointerList[k]=0;
		}

		//The AND operation can have at most as many entries as in the postings list of the first term
		//Iterator<Posting> firstIterator = DAATList.get(0).listIterator();
		if(DAATList.size()==1){
			ANDList.addAll(DAATList.get(0));
		}
		else{

			while(pointerList[0]<DAATList.get(0).size()){
				int docFirst=DAATList.get(0).get(pointerList[0]).getDocID();
				boolean endofList[]= new boolean[DAATList.size()];
				for(int j=0;j<DAATList.size();j++){
					endofList[j]=false;
				}
				boolean listPresent=false;

				for(int j=1;j<DAATList.size();j++){
					//Retrieving the docID of the posting pointed to by the current pointer
					int docCurrent = DAATList.get(j).get(pointerList[j]).getDocID();
					Iterator<Posting> currentIterator=DAATList.get(j).listIterator(pointerList[j]);
					if(currentIterator.hasNext()){
						currentIterator.next();
					}
					while(currentIterator.hasNext() && docCurrent<docFirst){
						docCurrent=currentIterator.next().getDocID();
						pointerList[j]++;
						countComparisons++;
					}
					if(currentIterator.hasNext()==false){
						endofList[j]=true;
					}
					if(docCurrent==docFirst){
						listPresent=true;
						countComparisons++;
						continue;
					}
					else if(docCurrent>docFirst){
						listPresent=false;
						countComparisons++;
						while(docFirst<docCurrent){
							pointerList[0]++;
							if(DAATList.get(0).get(pointerList[0])!=null){
								docFirst=DAATList.get(0).get(pointerList[0]).getDocID();
							}
							else
								endofList[0]=true;
							countComparisons++;
							if(endofList[j]==true && docFirst==docCurrent)
								endofList[j]=false;
						}
						break;
					}
				}
				if(listPresent==true){
					ANDList.add(DAATList.get(0).get(pointerList[0]));
					++pointerList[0];
				}
				boolean flagEnd=false;
				for(int l=0;l<DAATList.size();l++){
					if(endofList[l]==true){
						flagEnd=true;
						break;
					}
				}
				if(flagEnd==true)
					break;
			}
		}
		long endTime = System.nanoTime();
		double elapsedTime = ((endTime-startTime)/1000000000.0);
		if(ANDList.size()==0){
			bw.write("0 documents are found");
			bw.newLine();
			bw.write(countComparisons+" comparisons are made");
			bw.newLine();
			bw.write(elapsedTime+" seconds are used");
			bw.newLine();
			bw.write("nn comparisons are made with optimization");
			bw.newLine();
			bw.write("Result: ");
			bw.newLine();
		}
		else{
			bw.write(ANDList.size()+" documents are found");
			bw.newLine();
			bw.write(countComparisons+" comparisons are made");
			bw.newLine();
			bw.write(elapsedTime+" seconds are used");
			bw.newLine();
			bw.write("nn comparisons are made with optimization");
			bw.newLine();
			StringBuffer sb = new StringBuffer();
			sb.append("Result: ");

			//Collections.sort(ANDList, new DocIDComparator());
			for(int i=0;i<ANDList.size();i++){
				sb.append(ANDList.get(i).getDocID()+", ");
			}
			String result=sb.toString();
			result=result.replaceAll(", +$", "");
			bw.write(result);
			bw.newLine();

		}
	}

	private void docAtATimeQueryOR(String[] query) throws IOException {
		// TODO Auto-generated method stub
		StringBuffer querySb= new StringBuffer();
		querySb.append("FUNCTION: docAtATimeQueryOR ");
		for(int z=0;z<query.length;z++){
			querySb.append(query[z]+", ");
		}
		String queryStr=querySb.toString();
		queryStr=queryStr.replaceAll(", +$", "");
		bw.write(queryStr);
		bw.newLine();

		// Creating an ArrayList which stores the postings list of all the query terms
		LinkedList<LinkedList<Posting>> DAATList = new LinkedList<LinkedList<Posting>>();

		for(int i=0;i<query.length;i++){
			LinkedList<Posting> listSortedDAATTemp=Index.getIndex().get(query[i]).getPostingsListDAAT();
			if(listSortedDAATTemp!=null){
				DAATList.add(i, listSortedDAATTemp);
			}
		}

		int countComparisons=0;
		long startTime = System.nanoTime();

		LinkedList<Posting> ORList= new LinkedList<Posting>();

		//postingsListAttay contains the pointers to each of the postingslist
		int pointerList[] = new int[DAATList.size()];

		// Initializing each element of the postingListArray to the first posting of each of the postings list
		for(int k=0;k<DAATList.size();k++){
			pointerList[k]=0;
		}

		//The AND operation can have at most as many entries as in the postings list of the first term
		//Iterator<Posting> firstIterator = DAATList.get(0).listIterator();
		if(DAATList.size()==1){
			ORList.addAll(DAATList.get(0));
		}
		else{
			boolean endOfAllLists = false;
			boolean endList[] = new boolean[DAATList.size()];
			for(int j=0;j<DAATList.size();j++){
				endList[j]=false;
			}
			int minPos=0;
			while(!endOfAllLists){
				int minDocId=-1;
				for(int k=0;k<DAATList.size();k++){
					if(endList[k]==false){
					minDocId=DAATList.get(k).get(pointerList[k]).getDocID();
					}
				}
				if(minDocId==-1)
					break;

				for(int j=0;j<DAATList.size();j++){
					if(endList[j]==false){

						if(DAATList.get(j).get(pointerList[j]).getDocID()<=minDocId){
							minPos=j;
							minDocId=DAATList.get(j).get(pointerList[j]).getDocID();
							countComparisons++;
						}
					}
				}

				ORList.add(DAATList.get(minPos).get(pointerList[minPos]));

				for(int j=0;j<DAATList.size();j++){
					if(endList[j]==false){
						if(DAATList.get(j).get(pointerList[j]).getDocID()==minDocId){
							countComparisons++;
							pointerList[j]++;
							if(pointerList[j]==DAATList.get(j).size()){
								endList[j]=true;
							}
						}
					}
				}

				endOfAllLists=true;
				for(int k=0;k<endList.length;k++){
					if(endList[k]==false){
						endOfAllLists=false;
						break;
					}
				}


			}
		}
		long endTime = System.nanoTime();
		double elapsedTime = ((endTime-startTime)/1000000000.0);
		bw.write(ORList.size()+" documents are found");
		bw.newLine();
		bw.write(countComparisons+" comparisons are made");
		bw.newLine();
		bw.write(elapsedTime+" seconds are used");
		bw.newLine();
		bw.write("nn comparisons are made with optimization");
		bw.newLine();
		StringBuffer sb = new StringBuffer();
		sb.append("Result: ");

		//Collections.sort(ANDList, new DocIDComparator());
		for(int i=0;i<ORList.size();i++){
			sb.append(ORList.get(i).getDocID()+", ");
		}
		String result=sb.toString();
		result=result.replaceAll(", +$", "");
		bw.write(result);
		bw.newLine();

	}

}